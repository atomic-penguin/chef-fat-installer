<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>File: README [json-1.4.6 Documentation]</title>

	<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet" />

	<script src="./js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>
</head>

<body class="file">
	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="./README.html">README</a></li>
				
					<li class="file"><a href="./ext/json/ext/generator/Makefile.html">Makefile</a></li>
				
					<li class="file"><a href="./ext/json/ext/parser/Makefile.html">Makefile</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="./images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="./JSON.html">JSON</a></li>
				
					<li><a href="./JSON/Editor.html">JSON::Editor</a></li>
				
					<li><a href="./JSON/Editor/EditMenu.html">JSON::Editor::EditMenu</a></li>
				
					<li><a href="./JSON/Editor/FileMenu.html">JSON::Editor::FileMenu</a></li>
				
					<li><a href="./JSON/Editor/Gtk.html">JSON::Editor::Gtk</a></li>
				
					<li><a href="./JSON/Editor/Gtk/TreeIter.html">JSON::Editor::Gtk::TreeIter</a></li>
				
					<li><a href="./JSON/Editor/JSONTreeView.html">JSON::Editor::JSONTreeView</a></li>
				
					<li><a href="./JSON/Editor/MainWindow.html">JSON::Editor::MainWindow</a></li>
				
					<li><a href="./JSON/Editor/MenuExtension.html">JSON::Editor::MenuExtension</a></li>
				
					<li><a href="./JSON/Editor/OptionsMenu.html">JSON::Editor::OptionsMenu</a></li>
				
					<li><a href="./JSON/Editor/PopUpMenu.html">JSON::Editor::PopUpMenu</a></li>
				
					<li><a href="./JSON/Ext.html">JSON::Ext</a></li>
				
					<li><a href="./JSON/Ext/Generator.html">JSON::Ext::Generator</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods.html">JSON::Ext::Generator::GeneratorMethods</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Array.html">JSON::Ext::Generator::GeneratorMethods::Array</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Bignum.html">JSON::Ext::Generator::GeneratorMethods::Bignum</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/FalseClass.html">JSON::Ext::Generator::GeneratorMethods::FalseClass</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Fixnum.html">JSON::Ext::Generator::GeneratorMethods::Fixnum</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Float.html">JSON::Ext::Generator::GeneratorMethods::Float</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Hash.html">JSON::Ext::Generator::GeneratorMethods::Hash</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/NilClass.html">JSON::Ext::Generator::GeneratorMethods::NilClass</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/Object.html">JSON::Ext::Generator::GeneratorMethods::Object</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/String.html">JSON::Ext::Generator::GeneratorMethods::String</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/String/Extend.html">JSON::Ext::Generator::GeneratorMethods::String::Extend</a></li>
				
					<li><a href="./JSON/Ext/Generator/GeneratorMethods/TrueClass.html">JSON::Ext::Generator::GeneratorMethods::TrueClass</a></li>
				
					<li><a href="./JSON/Ext/Generator/State.html">JSON::Ext::Generator::State</a></li>
				
					<li><a href="./JSON/Ext/Parser.html">JSON::Ext::Parser</a></li>
				
					<li><a href="./JSON/GeneratorError.html">JSON::GeneratorError</a></li>
				
					<li><a href="./JSON/GeneratorError.html">JSON::GeneratorError</a></li>
				
					<li><a href="./JSON/JSONError.html">JSON::JSONError</a></li>
				
					<li><a href="./JSON/MissingUnicodeSupport.html">JSON::MissingUnicodeSupport</a></li>
				
					<li><a href="./JSON/NestingError.html">JSON::NestingError</a></li>
				
					<li><a href="./JSON/ParserError.html">JSON::ParserError</a></li>
				
					<li><a href="./JSON/Pure.html">JSON::Pure</a></li>
				
					<li><a href="./JSON/Pure/Generator.html">JSON::Pure::Generator</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods.html">JSON::Pure::Generator::GeneratorMethods</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/Array.html">JSON::Pure::Generator::GeneratorMethods::Array</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/FalseClass.html">JSON::Pure::Generator::GeneratorMethods::FalseClass</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/Float.html">JSON::Pure::Generator::GeneratorMethods::Float</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/Hash.html">JSON::Pure::Generator::GeneratorMethods::Hash</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/Integer.html">JSON::Pure::Generator::GeneratorMethods::Integer</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/NilClass.html">JSON::Pure::Generator::GeneratorMethods::NilClass</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/Object.html">JSON::Pure::Generator::GeneratorMethods::Object</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/String.html">JSON::Pure::Generator::GeneratorMethods::String</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/String/Extend.html">JSON::Pure::Generator::GeneratorMethods::String::Extend</a></li>
				
					<li><a href="./JSON/Pure/Generator/GeneratorMethods/TrueClass.html">JSON::Pure::Generator::GeneratorMethods::TrueClass</a></li>
				
					<li><a href="./JSON/Pure/Generator/State.html">JSON::Pure::Generator::State</a></li>
				
					<li><a href="./JSON/Pure/Parser.html">JSON::Pure::Parser</a></li>
				
					<li><a href="./Class.html">Class</a></li>
				
					<li><a href="./Date.html">Date</a></li>
				
					<li><a href="./DateTime.html">DateTime</a></li>
				
					<li><a href="./Enumerable.html">Enumerable</a></li>
				
					<li><a href="./Exception.html">Exception</a></li>
				
					<li><a href="./Kernel.html">Kernel</a></li>
				
					<li><a href="./Object.html">Object</a></li>
				
					<li><a href="./Range.html">Range</a></li>
				
					<li><a href="./Regexp.html">Regexp</a></li>
				
					<li><a href="./Struct.html">Struct</a></li>
				
					<li><a href="./Symbol.html">Symbol</a></li>
				
					<li><a href="./Time.html">Time</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h2>Description</h2>
<p>
This is a implementation of the <a href="JSON.html">JSON</a> specification
according to RFC 4627 <a
href="http://www.ietf.org/rfc/rfc4627.txt">www.ietf.org/rfc/rfc4627.txt</a>
. Starting from version 1.0.0 on there will be two variants available:
</p>
<ul>
<li><p>
A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.
</p>
</li>
<li><p>
The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
.
</p>
</li>
</ul>
<p>
Both variants of the <a href="JSON.html">JSON</a> generator generate UTF-8
character sequences by default. If an :ascii_only option with a true value
is given, they escape all non-ASCII and control characters with uXXXX
escape sequences, and support UTF-16 surrogate pairs in order to be able to
generate the whole range of unicode code points.
</p>
<p>
All strings, that are to be encoded as <a href="JSON.html">JSON</a>
strings, should be UTF-8 byte sequences on the Ruby side. To encode raw
binary strings, that aren&#8217;t UTF-8 encoded, please use the
to_json_raw_object method of String (which produces an object, that
contains a byte array) and decode the result on the receiving endpoint.
</p>
<p>
The <a href="JSON.html">JSON</a> parsers can parse UTF-8, UTF-16BE,
UTF-16LE, UTF-32BE, and UTF-32LE <a href="JSON.html">JSON</a> documents
under Ruby 1.8. Under Ruby 1.9 they take advantage of Ruby&#8217;s M17n
features and can parse all documents which have the correct String#encoding
set. If a document string has ASCII-8BIT as an encoding the parser attempts
to figure out which of the UTF encodings from above it is and trys to parse
it.
</p>
<h2>Installation</h2>
<p>
It&#8217;s recommended to use the extension variant of <a
href="JSON.html">JSON</a>, because it&#8217;s faster than the pure ruby
variant. If you cannot build it on your system, you can settle for the
latter.
</p>
<p>
Just type into the command line as root:
</p>
<pre>
  # rake install
</pre>
<p>
The above command will build the extensions and install them on your
system.
</p>
<pre>
  # rake install_pure
</pre>
<p>
or
</p>
<pre>
  # ruby install.rb
</pre>
<p>
will just install the pure ruby implementation of <a
href="JSON.html">JSON</a>.
</p>
<p>
If you use Rubygems you can type
</p>
<pre>
  # gem install json
</pre>
<p>
instead, to install the newest <a href="JSON.html">JSON</a> version.
</p>
<p>
There is also a pure ruby json only variant of the gem, that can be
installed with:
</p>
<pre>
  # gem install json_pure
</pre>
<h2>Compiling the extensions yourself</h2>
<p>
If you want to build the extensions yourself you need rake:
</p>
<pre>
  You can get it from rubyforge:
    http://rubyforge.org/projects/rake

  or just type

  # gem install rake

  for the installation via rubygems.
</pre>
<p>
If you want to create the parser.c file from its parser.rl file or draw
nice graphviz images of the state machines, you need ragel from: <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
</p>
<h2>Usage</h2>
<p>
To use <a href="JSON.html">JSON</a> you can
</p>
<pre>
  require 'json'
</pre>
<p>
to load the installed variant (either the extension &#8216;json&#8217; or
the pure variant &#8216;json_pure&#8217;). If you have installed the
extension variant, you can pick either the extension variant or the pure
variant by typing
</p>
<pre>
  require 'json/ext'
</pre>
<p>
or
</p>
<pre>
  require 'json/pure'
</pre>
<p>
Now you can parse a <a href="JSON.html">JSON</a> document into a ruby data
structure by calling
</p>
<pre>
  JSON.parse(document)
</pre>
<p>
If you want to generate a <a href="JSON.html">JSON</a> document from a ruby
data structure call
</p>
<pre>
  JSON.generate(data)
</pre>
<p>
You can also use the pretty_generate method (which formats the output more
verbosely and nicely) or fast_generate (which doesn&#8217;t do any of the
security checks generate performs, e. g. nesting deepness checks).
</p>
<p>
To create a valid <a href="JSON.html">JSON</a> document you have to make
sure, that the output is embedded in either a <a href="JSON.html">JSON</a>
array [] or a <a href="JSON.html">JSON</a> object {}. The easiest way to do
this, is by putting your values in a Ruby Array or Hash instance.
</p>
<p>
There are also the <a href="JSON.html">JSON</a> and JSON[] methods which
use parse on a String or generate a <a href="JSON.html">JSON</a> document
from an array or hash:
</p>
<pre>
  document = JSON 'test'  =&gt; 23 # =&gt; &quot;{\&quot;test\&quot;:23}&quot;
  document = JSON['test'] =&gt; 23 # =&gt; &quot;{\&quot;test\&quot;:23}&quot;
</pre>
<p>
and
</p>
<pre>
  data = JSON '{&quot;test&quot;:23}'  # =&gt; {&quot;test&quot;=&gt;23}
  data = JSON['{&quot;test&quot;:23}'] # =&gt; {&quot;test&quot;=&gt;23}
</pre>
<p>
You can choose to load a set of common additions to ruby core&#8217;s
objects if you
</p>
<pre>
  require 'json/add/core'
</pre>
<p>
After requiring this you can, e. g., serialise/deserialise Ruby ranges:
</p>
<pre>
  JSON JSON(1..10) # =&gt; 1..10
</pre>
<p>
To find out how to add <a href="JSON.html">JSON</a> support to other or
your own classes, read the section &#8220;More Examples&#8221; below.
</p>
<p>
To get the best compatibility to rails&#8217; <a href="JSON.html">JSON</a>
implementation, you can
</p>
<pre>
  require 'json/add/rails'
</pre>
<p>
Both of the additions attempt to require &#8216;json&#8217; (like above)
first, if it has not been required yet.
</p>
<h2>More Examples</h2>
<p>
To create a <a href="JSON.html">JSON</a> document from a ruby data
structure, you can call <a
href="JSON.html#method-i-generate">JSON.generate</a> like that:
</p>
<pre>
 json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
 # =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,\&quot;4..10\&quot;]&quot;
</pre>
<p>
To get back a ruby data structure from a <a href="JSON.html">JSON</a>
document, you have to call <a
href="JSON.html#method-i-parse">JSON.parse</a> on it:
</p>
<pre>
 JSON.parse json
 # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]
</pre>
<p>
Note, that the range from the original data structure is a simple string
now. The reason for this is, that <a href="JSON.html">JSON</a>
doesn&#8217;t support ranges or arbitrary classes. In this case the json
library falls back to call <a
href="Object.html#method-i-to_json">Object#to_json</a>, which is the same
as #.to_json.
</p>
<p>
It&#8217;s possible to add <a href="JSON.html">JSON</a> support
serialization to arbitrary classes by simply implementing a more
specialized version of the # method, that should return a <a
href="JSON.html">JSON</a> object (a hash converted to <a
href="JSON.html">JSON</a> with #) like this (don&#8217;t forget the *a for
all the arguments):
</p>
<pre>
 class Range
   def to_json(*a)
     {
       'json_class'   =&gt; self.class.name, # = 'Range'
       'data'         =&gt; [ first, last, exclude_end? ]
     }.to_json(*a)
   end
 end
</pre>
<p>
The hash key &#8216;json_class&#8217; is the class, that will be asked to
deserialise the <a href="JSON.html">JSON</a> representation later. In this
case it&#8217;s &#8216;Range&#8217;, but any namespace of the form
&#8216;A::B&#8217; or &#8217;::A::B&#8217; will do. All other keys are
arbitrary and can be used to store the necessary data to configure the
object to be deserialised.
</p>
<p>
If a the key &#8216;json_class&#8217; is found in a <a
href="JSON.html">JSON</a> object, the <a href="JSON.html">JSON</a> parser
checks if the given class responds to the json_create class method. If so,
it is called with the <a href="JSON.html">JSON</a> object converted to a
Ruby hash. So a range can be deserialised by implementing Range.json_create
like this:
</p>
<pre>
 class Range
   def self.json_create(o)
     new(*o['data'])
   end
 end
</pre>
<p>
Now it possible to serialise/deserialise ranges as well:
</p>
<pre>
 json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
 # =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;
 JSON.parse json
 # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
</pre>
<p>
<a href="JSON.html#method-i-generate">JSON.generate</a> always creates the
shortest possible string representation of a ruby data structure in one
line. This is good for data storage or network protocols, but not so good
for humans to read. Fortunately there&#8217;s also <a
href="JSON.html#method-i-pretty_generate">JSON.pretty_generate</a> (or <a
href="JSON.html#method-i-pretty_generate">JSON.pretty_generate</a>) that
creates a more readable output:
</p>
<pre>
 puts JSON.pretty_generate([1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10])
 [
   1,
   2,
   {
     &quot;a&quot;: 3.141
   },
   false,
   true,
   null,
   {
     &quot;json_class&quot;: &quot;Range&quot;,
     &quot;data&quot;: [
       4,
       10,
       false
     ]
   }
 ]
</pre>
<p>
There are also the methods <a href="Kernel.html#method-i-j">Kernel#j</a>
for generate, and <a href="Kernel.html#method-i-jj">Kernel#jj</a> for
pretty_generate output to the console, that work analogous to Core
Ruby&#8217;s p and the pp library&#8217;s pp methods.
</p>
<p>
The script tools/server.rb contains a small example if you want to test,
how receiving a <a href="JSON.html">JSON</a> object from a webrick server
in your browser with the javasript prototype library <a
href="http://www.prototypejs.org">www.prototypejs.org</a> works.
</p>
<h2>Speed Comparisons</h2>
<p>
I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the JSON-parser to estimate the speed up in the
C extension:
</p>
<pre>
 Comparing times (call_time_mean):
  1 ParserBenchmarkExt#parser   900 repeats:
        553.922304770 (  real) -&gt;   21.500x 
          0.001805307
  2 ParserBenchmarkYAML#parser  1000 repeats:
        224.513358139 (  real) -&gt;    8.714x 
          0.004454078
  3 ParserBenchmarkPure#parser  1000 repeats:
         26.755020642 (  real) -&gt;    1.038x 
          0.037376163
  4 ParserBenchmarkRails#parser 1000 repeats:
         25.763381731 (  real) -&gt;    1.000x 
          0.038814780
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
In the table above 1 is <a
href="JSON/Ext/Parser.html">JSON::Ext::Parser</a>, 2 is YAML.load with YAML
compatbile <a href="JSON.html">JSON</a> document, 3 is is <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a>, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport JSON-decoder converts the
input first to YAML and then uses the YAML-parser, the conversion seems to
slow it down so much that it is only as fast as the <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a>!
</p>
<p>
If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a> runs:
</p>
<pre>
 Comparing times (call_time_median):
  1 ParserBenchmarkExt#parser   900 repeats:
        800.592479481 (  real) -&gt;   26.936x 
          0.001249075
  2 ParserBenchmarkYAML#parser  1000 repeats:
        271.002390644 (  real) -&gt;    9.118x 
          0.003690004
  3 ParserBenchmarkRails#parser 1000 repeats:
         30.227910865 (  real) -&gt;    1.017x 
          0.033082008
  4 ParserBenchmarkPure#parser  1000 repeats:
         29.722384421 (  real) -&gt;    1.000x 
          0.033644676
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
I have benchmarked the JSON-Generator as well. This generated a few more
values, because there are different modes that also influence the achieved
speed:
</p>
<pre>
 Comparing times (call_time_mean):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        547.354332608 (  real) -&gt;   15.090x 
          0.001826970
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        443.968212317 (  real) -&gt;   12.240x 
          0.002252414
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        375.104545883 (  real) -&gt;   10.341x 
          0.002665923
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         49.978706968 (  real) -&gt;    1.378x 
          0.020008521
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         38.531868759 (  real) -&gt;    1.062x 
          0.025952543
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
          0.027079979
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.027569373
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
In the table above 1-3 are <a
href="JSON/Ext/Generator.html">JSON::Ext::Generator</a> methods. 4, 6, and
7 are <a href="JSON/Pure/Generator.html">JSON::Pure::Generator</a> methods
and 5 is the Rails <a href="JSON.html">JSON</a> generator. It is now a bit
faster than the generator_safe and generator_pretty methods of the pure
variant but slower than the others.
</p>
<p>
To achieve the fastest <a href="JSON.html">JSON</a> document output, you
can use the fast_generate method. Beware, that this will disable the
checking for circular Ruby data structures, which may cause <a
href="JSON.html">JSON</a> to go into an infinite loop.
</p>
<p>
Here are the median comparisons for completeness&#8217; sake:
</p>
<pre>
 Comparing times (call_time_median):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        708.258020939 (  real) -&gt;   16.547x 
          0.001411915
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        569.105020353 (  real) -&gt;   13.296x 
          0.001757145
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        482.825371244 (  real) -&gt;   11.280x 
          0.002071142
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         62.717626652 (  real) -&gt;    1.465x 
          0.015944481
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         43.965681162 (  real) -&gt;    1.027x 
          0.022745013
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
          0.022763968
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.023363113
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<h2>Author</h2>
<p>
Florian Frank <<a href="mailto:flori@ping.de">flori@ping.de</a>>
</p>
<h2>License</h2>
<p>
Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so
see the file GPL as well.
</p>
<h2>Download</h2>
<p>
The latest version of this library can be downloaded at
</p>
<ul>
<li><p>
<a
href="http://rubyforge.org/frs?group_id=953">rubyforge.org/frs?group_id=953</a>
</p>
</li>
</ul>
<p>
Online Documentation should be located at
</p>
<ul>
<li><p>
<a href="http://json.rubyforge.org">json.rubyforge.org</a>
</p>
</li>
</ul>

	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>
</body>
</html>

